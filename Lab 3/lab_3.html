<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratório 3</title>
    <link rel="icon" href="https://raw.githubusercontent.com/AndreMarques2002/processamentoVideoLabs/main/ufabc_icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/monokai-sublime.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/cpp.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-image: url('https://raw.githubusercontent.com/AndreMarques2002/processamentoVideoLabs/main/Background.png');
            background-size: cover;
            color: #333;
            margin: 0;
            overflow-x: hidden;
            line-height: 1.6;
        }
        
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #aaa;
            border-radius: 4px;
        }
        
        .header {
            width: 100%;
            position: fixed;
            top: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(58, 151, 147, 0.9);
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
            transition: all 0.3s ease;
        }

        .header.shrink {
            padding: 10px;
            background-color: rgba(58, 151, 147, 1);
        }

        .logo {
            width: 100px;
            cursor: pointer;
            transition: width 0.3s ease;
        }

        .header.shrink .logo {
            width: 80px;
        }

        .menu {
            display: flex;
            gap: 25px;
        }

        .menu-item {
            text-decoration: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: color 0.3s;
        }

        .menu-item:hover {
            color: #004d40;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            min-width: 160px;
            box-shadow: 0px 8px 16px rgba(0,0,0,0.3);
            background-color: #3a9793;
            text-align: center;
            z-index: 1;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(-10px);
        }

        .dropdown-content a {
            color: white;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }

        .dropdown:hover .dropdown-content {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

      	.title {
            text-align: center;
            margin-top: 150px;
            color: white;
            font-size: 2.5rem;
        }

        .section {
            margin: 20px;
            color: #222;
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 8px;
        }

        .code-container {
            background-color: #23241f;
            color: #abb2bf;
            border-radius: 8px;
            padding: 0px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .code-container code {
            color: #e06c75;
        }

        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px auto;
        }

        .image-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.3s ease;
        }

        .image-content:hover {
            transform: scale(1.05);
        }

        .image-content img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .image-content h4 {
            color: black;
            margin-top: 10px;
            text-align: center;
      	}

        .footer {
            width: 100%;
            background-color: rgba(58, 151, 147, 0.9);
            text-align: center;
            color: white;
            padding: 15px;
            font-size: 0.9rem;
            position: relative;
            bottom: 0;
        }
        .image-title {
            width: 100%;
            text-align: center;
            margin-top: 10px;
            color: black; /* Defina a cor que preferir para o título */
            font-size: 1.2rem;
		}
        .table-container {
            display: flex;
            justify-content: center;
            margin: 20px auto;
            padding: 10px;
        }
        
        table {
            width: 100%;
            max-width: 600px;
            border-collapse: collapse;
            text-align: center;
        }

        table, th, td {
            border: 2px solid black;
            padding: 8px;
        }

        th {
            background-color: #f0f0f0;
            font-weight: bold;
            color: #333;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

    </style>
</head>
<body>
    <header class="header" id="header">
        <img src="https://raw.githubusercontent.com/AndreMarques2002/processamentoVideoLabs/main/ufabc_icon.png" alt="Logo UFABC" class="logo" onclick="scrollToSection('home')">
        <nav class="menu">
            <a href="../index.html" class="menu-item">Home</a>
            <div class="dropdown">
                <a class="menu-item">Trabalhos</a>
                <div class="dropdown-content">
                    <a href="../Trabalho 1/trabalho_1.html">Trabalho T1</a>
                    <a href="../Trabalho 2/trabalho_2.html">Trabalho T2</a>
                    <a href="../Trabalho 3/trabalho_3.html">Trabalho T3</a>
                    <a href="../Trabalho 4/trabalho_4.html">Trabalho T4</a>
                    <a href="../Trabalho 5/trabalho_5.html">Trabalho T5</a>
                </div>
            </div>
           
            <div class="dropdown"> 
                <a class="menu-item">Relatórios</a>
                <div class="dropdown-content">
                    <a href="../Lab 1/lab_1.html">Laboratório 1</a>
                    <a href="../Lab 2/lab_2.html">Laboratório 2</a>
                    <a href="lab_3.html">Laboratório 3</a>
                    <a href="../Lab 4/lab_4.html">Laboratório 4</a>
                    <a href="../Lab 5/lab_5.html">Laboratório 5</a>
                </div>
            </div>
        </nav>
    </header>
    
    

    <h1 class="title">Laboratório 3 - Espaço de Cores</h1>

    <div class="section">
        <h2>Introdução</h2>
        <p class="normal-text">
            O presente laboratório explora o uso de conversão e processamento de cores para a detecção e rastreamento de objetos em ambientes visuais, utilizando a biblioteca OpenCV. O objetivo é compreender a teoria e a prática de diferentes espaços de cor, 
		como RGB, HSV e YCrCb, que são essenciais para a manipulação de imagens e a segmentação de objetos com base em suas cores.
        </p>
        <p class="normal-text">
        A atividade está estruturada em várias etapas, que incluem a aplicação de filtros e técnicas de detecção de bordas, o uso de operações de threshold para segmentação de objetos, e a implementação de programas que possam rastrear e identificar múltiplos 
		objetos coloridos em tempo real. Além disso, o laboratório abrange o estudo e aplicação do detector de bordas Canny e a inclusão de funções para salvar imagens e gravar vídeos, promovendo uma análise aprofundada sobre o efeito dos filtros e 
		das operações de detecção no resultado final.
        </p>
        

        <br>

        <h2>Fundamentos básicos</h2>
        <h3>Conversão de Espaços de Cor</h3>
        <p class="normal-text">
        	A conversão entre espaços de cor é uma técnica essencial em processamento de imagem, utilizada para otimizar a detecção de características específicas, como a segmentação de objetos por cor. Os espaços RGB, HSV e YCrCb representam diferentes 
		formas de codificar informações de cor. Por exemplo, o RGB utiliza três canais (vermelho, verde e azul), enquanto o HSV separa a cor em matiz, saturação e valor, facilitando a segmentação de cor independentemente da luminosidade. 
		</p>
        
        <p class="normal-text">
            Essas conversões são fundamentais para que algoritmos identifiquem padrões de cor em diferentes condições de iluminação.
        </p>
        
        <h3>Filtro Gaussiano e Conversão para HSV</h3>
        <p class="normal-text">
        	A aplicação de filtros gaussianos antes da conversão para o espaço HSV reduz o ruído nas imagens, suavizando as transições bruscas de cor e melhorando a precisão na detecção de objetos. O filtro gaussiano suaviza a imagem ao reduzir os detalhes 
		finos, o que ajuda a evitar falsos positivos na segmentação. No espaço HSV, a segmentação é menos sensível às variações de luminosidade, tornando-se mais eficaz para a identificação de objetos coloridos.
		</p>
        
        <h3>Detector de Bordas Canny</h3>
        <p class="normal-text">
            O detector de bordas Canny é uma técnica popular de detecção de bordas que utiliza a diferenciação de intensidade para identificar contornos nítidos em uma imagem. Este processo passa por três fases principais: aplicação de um filtro gaussiano para 
		suavização, cálculo do gradiente para identificação de bordas e, por fim, supressão de não-máximos para eliminar bordas irrelevantes. Aplicado após o filtro gaussiano e a conversão para HSV, o Canny pode auxiliar na delimitação clara dos contornos 
		de objetos coloridos, facilitando seu rastreamento.
        </p>
        
        <br>

        <h2>Materiais e Métodos</h2>
        <h3>Lista de Materiais</h3>
            <ul>
                <li><p class="normal-text">Computador com o sistema opercional Linux 22.04 instalado</p></li>
                <li><p class="normal-text">Biblioteca OpenCV devidamente instalada</p></li>
                <li><p class="normal-text">Webcam Microsoft</p></li>
                <li><p class="normal-text">Objetos coloridos (amarelo, verde e vermelho)</p></li>
            </ul>
        
        <br>
        
        <h2>Procedimentos Experimentais</h2>
        
        
        <p class="normal-text">
        	Para realizar o experimento proposto, foi feito um estudo teórico sobre a conversão de cores, analisando as principais conversões de espaços de cor disponíveis no OpenCV, incluindo RGB para GRAY, YCrCb e HSV, além de Bayer para RGB. Esse estudo elucidou a estrutura de cada espaço de cor e a relevância das conversões para a segmentação de objetos coloridos, com destaque para as diferenças entre RGB e HSV, úteis na detecção de cores e controle de luminosidade.
		</p>

        <p class="normal-text">
        	Na fase prática, implementou-se um programa para capturar imagens da webcam e convertê-las de RGB para HSV, utilizando a função inRange para definir intervalos de cor específicos. Objetos de três cores distintas foram posicionados diante da câmera, registrando seus valores HSV e RGB e ajustando os parâmetros para uma detecção eficiente.
        </p>
        
		<p class="normal-text">
        	O programa foi modificado para incluir um filtro gaussiano, aplicado à imagem antes da conversão para HSV, visando reduzir o ruído e suavizar áreas com variações bruscas de cor. Para comparação, exibiram-se as versões filtrada e não filtrada em janelas separadas, permitindo observar a melhoria na segmentação, especialmente em objetos com transições suaves.
		</p>
        
		<p class="normal-text">
        	Em seguida, foi estudado o detector de bordas Canny, adaptando o programa para aplicá-lo na imagem suavizada. Diferentes configurações do detector foram testadas para identificar os contornos dos objetos coloridos, buscando parâmetros ideais para um rastreamento preciso das bordas.
		</p>
        
		<p class="normal-text">
        	O programa também ganhou funcionalidade para salvar imagens e gravar vídeos. Ao pressionar a tecla [s], a imagem atual era salva, e com as teclas [k] e [h], era possível iniciar e encerrar a gravação de vídeos. Durante a gravação, rastreou-se o movimento dos objetos coloridos, permitindo uma análise detalhada do desempenho e precisão do programa.
		</p>

      	<p class="normal-text">
      		Por fim, desenvolveu-se um sistema para detectar e extrair múltiplos objetos coloridos simultaneamente, configurando-o para segmentar objetos vermelhos, azuis e verdes. Essa tarefa envolveu ajustes nos parâmetros de segmentação para cada cor e análise dos contornos, documentando a eficácia da segmentação e a capacidade do programa de identificar e separar objetos de diferentes cores em um único quadro.
        </p>
			
        <br>
        
        <h2>Resultados e Análises</h2>
        <h3>Detecção de objetos coloridos com filtro gaussiano</h3>
        <p class="normal-text">
        	Para a análise, foram escolhidos um objeto amarelo, verde e vermelho. Com a adição do filtro Gaussiano no código original, foi possível obter os seguintes valores para o espaço HSV empiricamente:
        </p>
        
      	<div class="code-container">
        <pre><code class="language-cpp">
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/videoio.hpp"
#include <iostream>
 
using namespace cv;
 
const int max_value_H = 360/2;
const int max_value = 255;
const String window_capture_name = "Video Capture";
const String window_detection_name = "Object Detection";
int low_H = 0, low_S = 0, low_V = 0;
int high_H = max_value_H, high_S = max_value, high_V = max_value;
 
static void on_low_H_thresh_trackbar(int, void *)
{
    low_H = min(high_H-1, low_H);
    setTrackbarPos("Low H", window_detection_name, low_H);
}
 
static void on_high_H_thresh_trackbar(int, void *)
{
    high_H = max(high_H, low_H+1);
    setTrackbarPos("High H", window_detection_name, high_H);
}
 
static void on_low_S_thresh_trackbar(int, void *)
{
    low_S = min(high_S-1, low_S);
    setTrackbarPos("Low S", window_detection_name, low_S);
}
 
static void on_high_S_thresh_trackbar(int, void *)
{
    high_S = max(high_S, low_S+1);
    setTrackbarPos("High S", window_detection_name, high_S);
}
 
static void on_low_V_thresh_trackbar(int, void *)
{
    low_V = min(high_V-1, low_V);
    setTrackbarPos("Low V", window_detection_name, low_V);
}
 
static void on_high_V_thresh_trackbar(int, void *)
{
    high_V = max(high_V, low_V+1);
    setTrackbarPos("High V", window_detection_name, high_V);
}
 
int main(int argc, char* argv[])
{
    VideoCapture cap(argc > 1 ? atoi(argv[1]) : 0);
 
    namedWindow(window_capture_name);
    namedWindow(window_detection_name);
 
    // Trackbars to set thresholds for HSV values
    createTrackbar("Low H", window_detection_name, &low_H, max_value_H, on_low_H_thresh_trackbar);
    createTrackbar("High H", window_detection_name, &high_H, max_value_H, on_high_H_thresh_trackbar);
    createTrackbar("Low S", window_detection_name, &low_S, max_value, on_low_S_thresh_trackbar);
    createTrackbar("High S", window_detection_name, &high_S, max_value, on_high_S_thresh_trackbar);
    createTrackbar("Low V", window_detection_name, &low_V, max_value, on_low_V_thresh_trackbar);
    createTrackbar("High V", window_detection_name, &high_V, max_value, on_high_V_thresh_trackbar);
 
    Mat frame, frame_HSV, frame_threshold;
    while (true) {
        cap >> frame;
        if(frame.empty())
        {
            break;
        }
 
        // Convert from BGR to HSV colorspace
        cvtColor(frame, frame_HSV, COLOR_BGR2HSV);
        // Detect the object based on HSV Range Values
        inRange(frame_HSV, Scalar(low_H, low_S, low_V), Scalar(high_H, high_S, high_V), frame_threshold);
 
        // Show the frames
        imshow(window_capture_name, frame);
        imshow(window_detection_name, frame_threshold);
 
        char key = (char) waitKey(30);
        if (key == 'q' || key == 27)
        {
            break;
        }
    }
    return 0;
}
		</code></pre>
      	</div>
        
        <section class="table-container">
    <table>
        <tr>
            <th>Cor</th>
            <th>Low H</th>
            <th>High H</th>
            <th>Low S</th>
            <th>High S</th>
            <th>Low V</th>
            <th>High V</th>
        </tr>
        <tr>
            <td>Amarelo</td>
            <td>20</td>
            <td>84</td>
            <td>100</td>
            <td>255</td>
            <td>100</td>
            <td>255</td>
        </tr>
        <tr>
            <td>Verde</td>
            <td>35</td>
            <td>130</td>
            <td>48</td>
            <td>197</td>
            <td>33</td>
            <td>255</td>
        </tr>
        <tr>
            <td>Vermelho</td>
            <td>0</td>
            <td>10</td>
            <td>100</td>
            <td>255</td>
            <td>100</td>
            <td>255</td>
        </tr>
    </table>
</section>


		<p class="normal-text">
        	E, abaixo estão os resultados obtidos.
		</p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%203/Parte%202/objeto_amarelo.jpg">
              <h4 class="image-title">Detecção do objeto amarelo com filtro Gaussiano</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%203/Parte%202/objeto_verde.jpg">
              <h4 class="image-title">Detecção do objeto verde com filtro Gaussiano</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%203/Parte%202/objeto_vermelho.jpg">
              <h4 class="image-title">Detecção do objeto vermelho com filtro Gaussiano</h4>
          </div>
        </section>
        
        <h3>Filtragem de objetos coloridos associada ao detector CANNY</h3>
        <p class="normal-text">
        A partir do código anterior, desenvolveu-se o script abaixo para submeter às imagens filtradas dos objetos em questão ao detector Canny. 
        </p>
        
        <div class="code-container">
        <pre><code class="language-cpp"> 
#include &lt;opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/videoio.hpp"
#include &lt;iostream&gt
 
using namespace cv;
 
const int max_value_H = 360/2;
const int max_value = 255;
const String window_capture_name2 = "Video Capture 2";
const String window_capture_name = "Video Capture";
const String window_detection_name = "Object Detection";
int low_H = 0, low_S = 0, low_V = 0;
int high_H = max_value_H, high_S = max_value, high_V = max_value;

int lowThreshold = 0;
const int max_lowThreshold = 100;
const int ratio = 3;
const int kernel_size = 3;
const char* window_name = "Edge Map";

Mat src_gray, dst, detected_edges, frame_filtro;
 
static void on_low_H_thresh_trackbar(int, void *)
{
    low_H = min(high_H-1, low_H);
    setTrackbarPos("Low H", window_detection_name, low_H);
}
 
static void on_high_H_thresh_trackbar(int, void *)
{
    high_H = max(high_H, low_H+1);
    setTrackbarPos("High H", window_detection_name, high_H);
}
 
static void on_low_S_thresh_trackbar(int, void *)
{
    low_S = min(high_S-1, low_S);
    setTrackbarPos("Low S", window_detection_name, low_S);
}
 
static void on_high_S_thresh_trackbar(int, void *)
{
    high_S = max(high_S, low_S+1);
    setTrackbarPos("High S", window_detection_name, high_S);
}
 
static void on_low_V_thresh_trackbar(int, void *)
{
    low_V = min(high_V-1, low_V);
    setTrackbarPos("Low V", window_detection_name, low_V);
}
 
static void on_high_V_thresh_trackbar(int, void *)
{
    high_V = max(high_V, low_V+1);
    setTrackbarPos("High V", window_detection_name, high_V);
}
 
static void CannyThreshold(int, void*) //Canny
{
    blur( src_gray, detected_edges, Size(3,3) );
 
    Canny( detected_edges, detected_edges, lowThreshold, lowThreshold*ratio, kernel_size );
 
    dst = Scalar::all(0);
 
    frame_filtro.copyTo( dst, detected_edges);
     
}
 
 
int main(int argc, char* argv[])
{
    VideoCapture cap(argc > 1 ? atoi(argv[1]) : 0);
 
   	namedWindow(window_capture_name);
    namedWindow(window_detection_name);
	namedWindow( window_name, WINDOW_AUTOSIZE ); //Canny
 
    // Trackbars to set thresholds for HSV values
    createTrackbar("Low H", window_detection_name, &low_H, max_value_H, on_low_H_thresh_trackbar);
    createTrackbar("High H", window_detection_name, &high_H, max_value_H, on_high_H_thresh_trackbar);
    createTrackbar("Low S", window_detection_name, &low_S, max_value, on_low_S_thresh_trackbar);
    createTrackbar("High S", window_detection_name, &high_S, max_value, on_high_S_thresh_trackbar);
    createTrackbar("Low V", window_detection_name, &low_V, max_value, on_low_V_thresh_trackbar);
    createTrackbar("High V", window_detection_name, &high_V, max_value, on_high_V_thresh_trackbar);
 
	createTrackbar( "Min Threshold:", window_name, &lowThreshold, max_lowThreshold, CannyThreshold );//Canny
 
    Mat frame, frame_HSV, frame_threshold;
    while (true) {
        cap >> frame;
        if(frame.empty())
        {
            break;
        }
 
		GaussianBlur( frame, frame_filtro, Size( 7, 7 ), 0, 0 );
        // Convert from BGR to HSV colorspace
        cvtColor(frame_filtro, frame_HSV, COLOR_BGR2HSV);
        // Detect the object based on HSV Range Values
        inRange(frame_HSV, Scalar(low_H, low_S, low_V), Scalar(high_H, high_S, high_V), frame_threshold);
	
		dst.create( frame_filtro.size(), frame_filtro.type() );//Canny
		cvtColor( frame_filtro, src_gray, COLOR_BGR2GRAY );//Canny
		CannyThreshold(0, 0); //Canny
		
        // Show the frames
        imshow(window_capture_name, frame_filtro);
        imshow(window_detection_name, frame_threshold);
        imshow( window_name, dst ); //Canny
 
        char key = (char) waitKey(30);
        if (key == 'q' || key == 27)
        {
            break;
        }
    }
    return 0;
}
		</code></pre>
      	</div>
        
        <br>
        
        <p class="normal-text">
        	Com este código, as imagens abaixo foram obtidas.
		</p>
        
         <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%203/Parte%202/objeto_amarelo_canny.png">
              <h4 class="image-title">Objeto verde submetido ao detector Canny</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%203/Parte%202/objeto_verde_canny.png">
              <h4 class="image-title">Objeto verde submetido ao detector Canny</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%203/Parte%202/objeto_vermelho_canny.png">
              <h4 class="image-title">Objeto vermelho submetido ao detector Canny</h4>
          </div>
        </section>

        <br>
        
        <h3>Extração simultânea de objetos coloridos</h3>
         <p class="normal-text">
        	Por fim, desenvolveu-se o código abaixo para detectar os três objetos coloridos utilizados simultaneamente. Para tanto, ao invés de exibir uma tela para seleção manual dos parâmetros HSV para filtrar cada cor, o programa foi pré-configurado com os valores obtidos experimentalmente na primeira parte do experimento.
		</p>
        
        <div class="code-container">
        <pre><code class="language-cpp">
// Include Libraries        
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;

using namespace cv;
using namespace std;

// Janela para captura de vídeo e exibição
const String window_capture_name = "Video Capture";
const String window_detection_name = "Object Detection";

// Faixas de HSV para cores diferentes
int low_H_yellow = 20, low_S_yellow = 100, low_V_yellow = 100;
int high_H_yellow = 84, high_S_yellow = 255, high_V_yellow = 255;

int low_H_green = 35, low_S_green = 48, low_V_green = 33;
int high_H_green = 130, high_S_green = 197, high_V_green = 255;

int low_H_red1 = 0, low_S_red1 = 100, low_V_red1 = 100;
int high_H_red1 = 10, high_S_red1 = 255, high_V_red1 = 255;

int low_H_red2 = 170, low_S_red2 = 100, low_V_red2 = 100;
int high_H_red2 = 180, high_S_red2 = 255, high_V_red2 = 255;

int main(int argc, char* argv[])
{
    // Captura de vídeo (por padrão, usa a webcam)
    VideoCapture cap(argc > 1 ? atoi(argv[1]) : 0);
    if (!cap.isOpened()) {
        cout << "Erro ao abrir a câmera!" << endl;
        return -1;
    }

    // Criação de janelas
    namedWindow(window_capture_name);
    namedWindow(window_detection_name);

    Mat frame, frame_HSV, mask_yellow, mask_green, mask_red1, mask_red2, mask_red, mask_combined;

    while (true) {
        // Captura o frame
        cap >> frame;
        if (frame.empty()) {
            cout << "Fim do vídeo." << endl;
            break;
        }

        // Converte o frame de BGR para HSV
        cvtColor(frame, frame_HSV, COLOR_BGR2HSV);

        // Criação das máscaras para cada cor
        inRange(frame_HSV, Scalar(low_H_yellow, low_S_yellow, low_V_yellow), Scalar(high_H_yellow, high_S_yellow, high_V_yellow), mask_yellow);
        inRange(frame_HSV, Scalar(low_H_green, low_S_green, low_V_green), Scalar(high_H_green, high_S_green, high_V_green), mask_green);
        inRange(frame_HSV, Scalar(low_H_red1, low_S_red1, low_V_red1), Scalar(high_H_red1, high_S_red1, high_V_red1), mask_red1);
        inRange(frame_HSV, Scalar(low_H_red2, low_S_red2, low_V_red2), Scalar(high_H_red2, high_S_red2, high_V_red2), mask_red2);

        // Combina as duas faixas de vermelho
        mask_red = mask_red1 | mask_red2;

        // Combina todas as máscaras (amarelo, verde e vermelho)
        mask_combined = mask_yellow | mask_green | mask_red;

        // Mostrar os frames originais e a detecção combinada
        imshow(window_capture_name, frame);
        imshow(window_detection_name, mask_combined);

        // Pressione 'q' ou 'ESC' para sair
        char key = (char)waitKey(30);
        if (key == 'q' || key == 27) {
            break;
        }
    }
    return 0;
}
		</code></pre>
      	</div>
        
        <br>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%203/Parte%203/Objetos_parte_3.jpg">
              <h4 class="image-title">Filtragem simultânea dos objetos</h4>
          </div>
        </section>
        
      
        <h2>Conclusões e Comentários Finais</h2>
        <p class="normal-text">
        	O laboratório explorou de maneira prática o uso de conversão e processamento de cores para a detecção e rastreamento de objetos em ambientes visuais. Utilizando a biblioteca OpenCV, os experimentos demonstraram a eficácia de diferentes espaços 
		de cor (RGB, HSV e YCrCb) na segmentação de objetos coloridos. A aplicação de filtros gaussianos antes da conversão para HSV mostrou ser essencial na redução de ruído e melhoria da precisão na segmentação. A combinação da técnica de detecção de 
		bordas Canny com a conversão para HSV foi eficaz na delimitação clara dos contornos dos objetos, facilitando seu rastreamento em tempo real. O estudo incluiu a implementação de programas para capturar, processar e armazenar imagens e vídeos, 
		destacando a importância de ajustar parâmetros para uma detecção eficiente. Além disso, a capacidade de segmentar e rastrear múltiplos objetos coloridos simultaneamente demonstrou a eficácia e aplicabilidade das técnicas utilizadas. Sendo assim, 
		esses métodos e práticas aprimoram a compreensão da manipulação de imagens nos diferentes espaços de cores.
	</p>
        
    </div>

    </section>
    </main>

    <footer class="footer">
        <p>&copy; 2024 PROCESSAMENTO DE VÍDEO - UFABC</p>
    </footer>

    <script>
        function scrollToSection(sectionId) {
            document.getElementById(sectionId).scrollIntoView({ behavior: 'smooth' });
        }

        window.addEventListener('scroll', () => {
            const header = document.getElementById('header');
            if (window.scrollY > 50) {
                header.classList.add('shrink');
            } else {
                header.classList.remove('shrink');
            }
        });
    </script>
</body>
</html>
