<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratório 4</title>
    <link rel="icon" href="https://raw.githubusercontent.com/AndreMarques2002/processamentoVideoLabs/main/ufabc_icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/monokai-sublime.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/cpp.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-image: url('https://raw.githubusercontent.com/AndreMarques2002/processamentoVideoLabs/main/Background.png');
            background-size: cover;
            color: #333;
            margin: 0;
            overflow-x: hidden;
            line-height: 1.6;
        }
        
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #aaa;
            border-radius: 4px;
        }
        
        .header {
            width: 100%;
            position: fixed;
            top: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(58, 151, 147, 0.9);
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
            transition: all 0.3s ease;
        }

        .header.shrink {
            padding: 10px;
            background-color: rgba(58, 151, 147, 1);
        }

        .logo {
            width: 100px;
            cursor: pointer;
            transition: width 0.3s ease;
        }

        .header.shrink .logo {
            width: 80px;
        }

        .menu {
            display: flex;
            gap: 25px;
        }

        .menu-item {
            text-decoration: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: color 0.3s;
        }

        .menu-item:hover {
            color: #004d40;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            min-width: 160px;
            box-shadow: 0px 8px 16px rgba(0,0,0,0.3);
            background-color: #3a9793;
            text-align: center;
            z-index: 1;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(-10px);
        }

        .dropdown-content a {
            color: white;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }

        .dropdown:hover .dropdown-content {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

      	.title {
            text-align: center;
            margin-top: 150px;
            color: white;
            font-size: 2.5rem;
        }

        .section {
            margin: 20px;
            color: #222;
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 8px;
        }

        .code-container {
            background-color: #23241f;
            color: #abb2bf;
            border-radius: 8px;
            padding: 0px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .code-container code {
            color: #e06c75;
        }

        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px auto;
        }

        .image-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.3s ease;
        }

        .image-content:hover {
            transform: scale(1.05);
        }

        .image-content img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .image-content h4 {
          color: black;
          margin-top: 10px;
          text-align: center;
      	}

        .footer {
            width: 100%;
            background-color: rgba(58, 151, 147, 0.9);
            text-align: center;
            color: white;
            padding: 15px;
            font-size: 0.9rem;
            position: relative;
            bottom: 0;
        }
        .image-title {
    width: 100%;
    text-align: center;
    margin-top: 10px;
    color: black; /* Defina a cor que preferir para o título */
    font-size: 1.2rem;
}

    </style>
</head>
<body>
    <header class="header" id="header">
        <img src="https://raw.githubusercontent.com/AndreMarques2002/processamentoVideoLabs/main/ufabc_icon.png" alt="Logo UFABC" class="logo" onclick="scrollToSection('home')">
        <nav class="menu">
            <a href="../index.html" class="menu-item">Home</a>
            <div class="dropdown">
                <a class="menu-item">Trabalhos</a>
                <div class="dropdown-content">
                    <a href="../Trabalho 1/trabalho_1.html">Trabalho T1</a>
                    <a href="../Trabalho 2/trabalho_2.html">Trabalho T2</a>
                    <a href="../Trabalho 3/trabalho_3.html">Trabalho T3</a>
                    <a href="../Trabalho 4/trabalho_4.html">Trabalho T4</a>
                    <a href="../Trabalho 5/trabalho_5.html">Trabalho T5</a>
		    <a href="../Trabalho 6/trabalho_6.html">Trabalho T6</a>
                    <a href="../Trabalho 7/trabalho_7.html">Trabalho T7</a>
                    <a href="../Trabalho 8/trabalho_8.html">Trabalho T8</a>
                </div>
            </div>
            <div class="dropdown">
                <a class="menu-item">Relatórios</a>
                <div class="dropdown-content">
                    <a href="../Lab 1/lab_1.html">Laboratório 1</a>
                    <a href="../Lab 2/lab_2.html">Laboratório 2</a>
                    <a href="../Lab 3/lab_3.html">Laboratório 3</a>
                    <a href="lab_4.html">Laboratório 4</a>
                    <a href="../Lab 5/lab_5.html">Laboratório 5</a>
		    <a href="../Lab 7/lab_7.html">Laboratório 7</a>
                </div>
            </div>
        </nav>
    </header>

    <h1 class="title">Laboratório 4 - Histograma e Limiarização</h1>

    <main id="home">
        <section class="section">
            <h2>Introdução</h2>
            <p class="normal-text">
        <p class="normal-text">
           O processamento de imagens digitais emprega técnicas essenciais para o aprimoramento e análise das características visuais presentes nas imagens. Entre essas técnicas, a equalização de histogramas e a limiarização destacam-se por possibilitarem o ajuste 
		de contraste e a segmentação de elementos relevantes.
        </p>
        
        <p class="normal-text">
        	Neste laboratório, utiliza-se a biblioteca OpenCV em C++ para implementar a equalização de histogramas em imagens em tons de cinza, melhorando o contraste das imagens originais. A equalização redistribui as intensidades dos pixels, promovendo uma 
		representação mais uniforme dos níveis de intensidade.
        </p>
        
        <p class="normal-text">
        	Os experimentos incluem também a captura de imagens em tempo real via webcam, aplicando tanto a equalização de histogramas quanto a limiarização para conversão em imagem binária. Este processo evidencia objetos ou pessoas, facilitando a segmentação 
		e a análise visual. Com essas práticas, busca-se compreender os efeitos da equalização e da limiarização no contraste e na segmentação de imagens.
        </p>

        <br>

        <h2>Fundamentos básicos</h2>
        <p class="normal-text">
        	Em processamento de imagens, a conversão para tons de cinza é uma técnica inicial que simplifica a análise visual ao representar a imagem com apenas intensidades de luz, facilitando a detecção de padrões sem interferência de cores.
        </p>
        
        <p class="normal-text">
        	O histograma de uma imagem representa a distribuição das intensidades de pixel, mostrando a frequência de cada nível de cinza. A equalização de histogramas é um processo que redistribui essas intensidades para aumentar o contraste, melhorando a 
		visibilidade de detalhes em áreas claras e escuras.
        </p>
        
        <p class="normal-text">
        	A limiarização (ou binarização) é uma técnica que transforma uma imagem em preto e branco com base em um valor limite. Pixels com intensidades acima do limiar são convertidos em branco, enquanto os demais são convertidos em preto, criando uma 
		imagem binária que facilita a segmentação de objetos e áreas de interesse. Esses fundamentos formam a base para a análise e o aprimoramento de imagens digitais.
        </p>

        <br>

        <h2>Materiais e Métodos</h2>
        <h3>Lista de Materiais</h3>
            <ul>
                <li><p class="normal-text">Computador com o sistema opercional Linux 22.04 instalado</p></li>
                <li><p class="normal-text">Biblioteca OpenCV devidamente instalada</p></li>
                <li><p class="normal-text">Webcam Microsoft</p></li>
                <li><p class="normal-text">Objetos colorido (vermelho)</p></li>
            </ul>
        
        <br>
        
        <h2>Procedimentos Experimentais</h2>
        <p class="normal-text">
        	Para a realização dos experimentos, foram implementados programas em C++ utilizando a biblioteca OpenCV, com o objetivo de aplicar e analisar técnicas de processamento de imagem, como a conversão para tons de cinza, cálculo e equalização de 
		histogramas e limiarização.
		</p>
        
        <p class="normal-text">
        	As imagens de entrada foram carregadas e convertidas para tons de cinza, quando necessário, simplificando a análise e preparando-as para o cálculo de histogramas e a aplicação de limiarização. Gerou-se também os histogramas para avaliar a 
		distribuição de intensidade dos pixels antes e depois da equalização, que foi aplicada para aumentar o contraste e permitir uma melhor visualização dos detalhes em áreas de baixa e alta intensidade.
      	</p>

      	<p class="normal-text">
      		Ademais, aplicou-se a técnica de limiarização para gerar uma imagem binária, onde áreas acima e abaixo de um valor limiar foram separadas, facilitando a segmentação de objetos e áreas de interesse. A limiarização foi realizada tanto com 
		imagens originais quanto equalizadas, para analisar o impacto da equalização no resultado binário.
      	</p>
        
			
        <br>
        
        <h2>Resultados e Análises</h2>
        <h3>Parte 1</h3>
        <p class="normal-text">
        	O primeiro experimento envolveu o desenvolvimento de um programa para ler uma imagem, convertê-la para tons de cinza, calcular o histograma e realizar a equalização do histograma. A equalização de histograma é uma técnica que melhora o contraste da imagem, redistribuindo os níveis de intensidade de forma mais uniforme. A seguir, é apresentado o código utilizado para realizar essas operações, juntamente com os resultados obtidos.
      	</p>
        
        <div class="code-container">
        <pre><code class="language-cpp">
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"
#include &lt;iostream&gt;

using namespace cv;
using namespace std;

void saveHistogramImage(const Mat& hist, const string& filename) {
    int hist_w = 512, hist_h = 400;
    int bin_w = cvRound((double) hist_w / hist.rows);
    Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));

    normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());

    for (int i = 1; i < hist.rows; i++) {
        line(histImage, Point(bin_w * (i - 1), hist_h - cvRound(hist.at<float>(i - 1))),
             Point(bin_w * i, hist_h - cvRound(hist.at<float>(i))),
             Scalar(255, 255, 255), 2, 8, 0);
    }

    imwrite(filename, histImage);
}

int main(int argc, char** argv) {
    CommandLineParser parser(argc, argv, "{@input | Gabriel.jpg | input image}");
    Mat src = imread(samples::findFile(parser.get<String>("@input")), IMREAD_COLOR);
    if (src.empty()) {
        cout << "Could not open or find the image!\n" << endl;
        return -1;
    }

    Mat gray;
    cvtColor(src, gray, COLOR_BGR2GRAY);

    Mat hist;
    int histSize = 256;
    float range[] = {0, 256};
    const float* histRange[] = {range};
    calcHist(&gray, 1, 0, Mat(), hist, 1, &histSize, histRange, true, false);

    Mat equalized;
    equalizeHist(gray, equalized);

    Mat equalizedHist;
    calcHist(&equalized, 1, 0, Mat(), equalizedHist, 1, &histSize, histRange, true, false);

    imshow("Source image", src);
    imshow("Gray image", gray);
    imshow("Equalized Image", equalized);
//    imshow("Histograma", hist);
//    imshow("Histograma Eq", equalizedHist);

    while (true) {
        char c = (char)waitKey();
        if (c == 's') {
            imwrite("gray_image.jpg", gray);
            imwrite("equalized_image.jpg", equalized);
            saveHistogramImage(hist, "histogram_before.jpg");
            saveHistogramImage(equalizedHist, "histogram_after.jpg");
        } else if (c == 'q') {
            break;
        }
    }

    return 0;
}
		</code></pre>
      	</div>

        <p class="normal-text">
        	E, abaixo estão os resultados obtidos.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Andre_original.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Gabriel_original.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Vinicius_original.jpg">
          </div>
        </section>
        <h4 class="image-title">Foto original dos integrantes</h4>
        
        <p class="normal-text">
        	Em seguida, converteu-se as omagens originais para tons de cinza.
        </p>

        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Andre_gray_image.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Gabriel_gray_image.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Vinicius_gray_image.jpg">
          </div>
        </section>
        <h4 class="image-title">Fotos convertidas para tons de cinza</h4>
        
        <p class="normal-text">
        	Depois, as imagens foram equalizadas também.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Andre_equalized_image.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Gabriel_equalized_image.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Vinicius_equalized_image.jpg">
          </div>
        </section>
        <h4 class="image-title">Fotos equalizadas</h4>
        
        <p class="normal-text">
        	Por fim, foram exportados os histogramas antes e após a equalização.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Andre_histogram_before.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Gabriel_histogram_before.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Vinicius_histogram_before.jpg">
          </div>
        </section>
        <h4 class="image-title">Histogramas pré equalização</h4>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Andre_histogram_after.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Gabriel_histogram_after.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%201/Vinicius_histogram_after.jpg">
          </div>
        </section>
        <h4 class="image-title">Histogramas pós equalização</h4>
        
        <br>
        
        <h3>Parte 2</h3>
        <p class="normal-text">
        	Para o segundo experimento, o código foi modificado para capturar imagens da webcam e aplicar a equalização de histograma em tempo real. Este experimento permite observar a eficácia da equalização em diferentes condições de iluminação e cenários ao vivo. A seguir, é apresentado o código desenvolvido para capturar a imagem da webcam, convertê-la para tons de cinza, aplicar a equalização e exibir as imagens em janelas ao vivo.
        </p>
        
        <div class="code-container">
        <pre><code class="language-cpp"> 
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include &lt;iostream&gt;

using namespace cv;
using namespace std;

void saveHistogramImage(const Mat& hist, const string& filename) {
    int hist_w = 512, hist_h = 400;
    int bin_w = cvRound((double) hist_w / hist.rows);
    Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));

    normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());

    for (int i = 1; i < hist.rows; i++) {
        line(histImage, Point(bin_w * (i - 1), hist_h - cvRound(hist.at<float>(i - 1))),
             Point(bin_w * i, hist_h - cvRound(hist.at<float>(i))),
             Scalar(255, 255, 255), 2, 8, 0);
    }

    imwrite(filename, histImage);
}

int main(int argc, char** argv) {
    VideoCapture cap(0); // Abre a webcam padrão
    if (!cap.isOpened()) {
        cout << "Erro ao abrir a webcam!" << endl;
        return -1;
    }

    Mat frame, gray, equalized;
    Mat hist, equalizedHist;
    int histSize = 256;
    float range[] = {0, 256};
    const float* histRange[] = {range};

    while (true) {
        cap >> frame; // Captura um frame da webcam
        if (frame.empty()) {
            cout << "Erro ao capturar frame!" << endl;
            break;
        }

        cvtColor(frame, gray, COLOR_BGR2GRAY);
        equalizeHist(gray, equalized);

        calcHist(&gray, 1, 0, Mat(), hist, 1, &histSize, histRange, true, false);
        calcHist(&equalized, 1, 0, Mat(), equalizedHist, 1, &histSize, histRange, true, false);

        imshow("Webcam - Gray", gray);
        imshow("Webcam - Equalized", equalized);

        char c = (char)waitKey(30);
        if (c == 's') {
            imwrite("webcam_gray.jpg", gray);
            imwrite("webcam_equalized.jpg", equalized);
            saveHistogramImage(hist, "webcam_histogram_before.jpg");
            saveHistogramImage(equalizedHist, "webcam_histogram_after.jpg");
        } else if (c == 'q') {
            break;
        }
    }

    cap.release();
    destroyAllWindows();

    return 0;
}
		</code></pre>
      	</div>
        
        
        <p class="normal-text">
        	Assim, as imagens obtidas através da webcam, foram convertidas para tons de cinza.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Andre_webcam_gray.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Gabriel_webcam_gray.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Vinicius_webcam_gray.jpg">
          </div>
        </section>
        <h4 class="image-title">Imagens da webcam convertidas para tons de cinza</h4>
        
        <p class="normal-text">
        	Em seguida, as imagens foram equalizadas.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Andre_webcam_equalized.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Gabriel_webcam_equalized.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Vinicius_webcam_equalized.jpg">
          </div>
        </section>
        <h4 class="image-title">Imagens da webcam equalizadas</h4>
        
        <p class="normal-text">
        	Depois, exportou-se os histogramas antes e após a equalização.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Andre_webcam_histogram_before.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Gabriel_webcam_histogram_before.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Vinicius_webcam_histogram_before.jpg">
          </div>
        </section>
        <h4 class="image-title">Histogramas pré equalização (webcam)</h4>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Andre_webcam_histogram_after.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Gabriel_webcam_histogram_after.jpg">
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/Vinicius_webcam_histogram_after.jpg">
          </div>
        </section>
        <h4 class="image-title">Histogramas pós equalização (webcam)</h4>
        
        <p class="normal-text">
        	Utilizando-se um objeto vermelho, converteu-se a imagem para tons de cinza também. E, em seguida, aplicou-se a eqalização.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/objeto_webcam_gray.jpg">
              <h4 class="image-title">Objeto vermelho convertida para tons de cinza (webcam)</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/objeto_webcam_equalized.jpg">
              <h4 class="image-title">Objeto vermelho equalizado (webcam)</h4>
          </div>
        </section>
        
        <p class="normal-text">
        	Por fim, exportou-se os histogramas.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/objeto_webcam_histogram_before.jpg">
              <h4 class="image-title">Histograma do objeto vermelho pré equalização (webcam)</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%202/objeto_webcam_histogram_after.jpg">
              <h4 class="image-title">Histograma do objeto vermelho pós equalização (webcam)</h4>
          </div>
        </section>

        <br>
        
        <h3>Parte 3</h3>
        <p class="normal-text">
        	No terceiro experimento, foi incluída a equalização de histograma antes da aplicação da limiarização para obter imagens binárias. A binarização é uma técnica que converte a imagem em preto e branco, destacando os objetos de interesse. A equalização prévia melhora a clareza e definição das imagens binárias. A seguir, é apresentado o código utilizado para realizar a equalização e a binarização, juntamente com a comparação dos resultados com e sem equalização.
        </p>
        
        <div class="code-container">
        <pre><code class="language-cpp">
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include &lt;iostream&gt;

using namespace cv;
using namespace std;

int threshold_value = 0;
int threshold_type = 3;
int const max_value = 255;
int const max_type = 4;
int const max_binary_value = 255; /* variáveis e constantes da limiarização */

const char* window_name = "Threshold Demo";
 
const char* trackbar_type = "Type: \n 0: Binary \n 1: Binary Inverted \n 2: Truncate \n 3: To Zero \n 4: To Zero Inverted";
const char* trackbar_value = "Value";


Mat frame, gray, equalized;
Mat hist, equalizedHist;
Mat dst;
    
void saveHistogramImage(const Mat& hist, const string& filename) {
    int hist_w = 512, hist_h = 400;
    int bin_w = cvRound((double) hist_w / hist.rows);
    Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));

    normalize(hist, hist, 0, histImage.rows, NORM_MINMAX, -1, Mat());

    for (int i = 1; i < hist.rows; i++) {
        line(histImage, Point(bin_w * (i - 1), hist_h - cvRound(hist.at<float>(i - 1))),
             Point(bin_w * i, hist_h - cvRound(hist.at<float>(i))),
             Scalar(255, 255, 255), 2, 8, 0);
    }

    imwrite(filename, histImage);
}

static void Threshold_Demo( int, void* )
{
    /* 0: Binary
     1: Binary Inverted
     2: Threshold Truncated
     3: Threshold to Zero
     4: Threshold to Zero Inverted
    */
    threshold( equalized, dst, threshold_value, max_binary_value, threshold_type );
}

int main(int argc, char** argv) 
{
    VideoCapture cap(0); // Abre a webcam padrão
    if (!cap.isOpened()) {
        cout << "Erro ao abrir a webcam!" << endl;
        return -1;
    }
    
    namedWindow( window_name, WINDOW_AUTOSIZE ); // Cria janela para exibição
    
    createTrackbar( trackbar_type,
                    window_name, &threshold_type,
                    max_type, Threshold_Demo ); // Create a Trackbar to choose type of Threshold
 
    createTrackbar( trackbar_value,
                    window_name, &threshold_value,
                    max_value, Threshold_Demo ); // Create a Trackbar to choose Threshold value
   
    int histSize = 256;
    float range[] = {0, 256};
    const float* histRange[] = {range};

    while (true) {
        cap >> frame; // Captura um frame da webcam
        if (frame.empty()) {
            cout << "Erro ao capturar frame!" << endl;
            break;
        }

        cvtColor(frame, gray, COLOR_BGR2GRAY);
        equalizeHist(gray, equalized);

		Threshold_Demo( 0, 0 ); /* chama função threshold*/

        calcHist(&gray, 1, 0, Mat(), hist, 1, &histSize, histRange, true, false);
        calcHist(&equalized, 1, 0, Mat(), equalizedHist, 1, &histSize, histRange, true, false);


        imshow("Webcam - Gray", gray);
        imshow("Webcam - Equalized", equalized);
		imshow( window_name, dst );

        char c = (char)waitKey(30);
        if (c == 's') {
			imwrite("webcam_binary_threshold.jpg", dst);
            imwrite("webcam_gray.jpg", gray);
            imwrite("webcam_equalized.jpg", equalized);
            saveHistogramImage(hist, "webcam_histogram_before.jpg");
            saveHistogramImage(equalizedHist, "webcam_histogram_after.jpg");
        } 
        else if (c == 'q') 
        {
            break;
        }
    }

    cap.release();
    destroyAllWindows();

    return 0;
}
		</code></pre>
      	</div>
        
        <p class="normal-text">
        	A partir do código acima, foi possível obter as imagens com thresholding aliada à equalização.
        </p>
        
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%203/Vinicius_webcam_binary_threshold_EqualizeOff.jpg">
              <h4 class="image-title">Imagem com thresholding sem equalização</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%203/Vinicius_webcam_binary_thresholda_EqualizeOn.jpg">
              <h4 class="image-title">Imagem com thresholding com equalização</h4>
          </div>
        </section>
        
        <p class="normal-text">
        	Repetiu-se a análise anterior para um objeto verde também.
        </p>
        
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%203/objeto_webcam_binary_threshold.jpg">
              <h4 class="image-title">Objeto verde com thresholding sem equalização</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%203/objeto_webcam_binary_threshold_EqualizeOn.jpg">
              <h4 class="image-title">Objeto verde com thresholding com equalização</h4>
          </div>
        </section>
        
        <br>
        
        
        <h3>Parte 4</h3>
        <p class="normal-text">
        	Finalmente, o quarto experimento explorou a equalização de histograma nas imagens coloridas, onde cada canal de cor foi equalizado separadamente antes de serem combinados novamente na imagem colorida de saída. Este experimento mostrou que a equalização dos canais de cor individualmente pode melhorar a vivacidade e distribuição das cores na imagem final. A seguir, é apresentado o código desenvolvido para separar os canais de cor, aplicar a equalização em cada um e recombiná-los, resultando em imagens coloridas com melhor qualidade visual.
        </p>
        
        <div class="code-container">
        <pre><code class="language-cpp">
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <iostream>

using namespace cv;
using namespace std;

/* Variáveis e Constantes do programa original do site OpenCv)*/
int histSize = 256;
float range[] = {0, 256};
const float* histRange[] = {range}; 
    
/* função feita pelo André para construir e salvar o histograma dos 3 canais (RGB) */
void saveHistogramImage(const Mat& b_hist, const Mat& g_hist, const Mat& r_hist, const string& filename) 
{
    int hist_w = 512, hist_h = 400;
    int bin_w = cvRound((double) hist_w/histSize);
    Mat histImage(hist_h, hist_w, CV_8UC3, Scalar(0, 0, 0));

    normalize(b_hist, b_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat() );
    normalize(g_hist, g_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat() );
    normalize(r_hist, r_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat() );
    
    for (int i = 1; i < histSize; i++) 
    {
        line( histImage, Point( bin_w*(i-1), hist_h - cvRound(b_hist.at<float>(i - 1))),
             Point(bin_w * i, hist_h - cvRound(b_hist.at<float>(i))),
             Scalar(255, 255, 255), 2, 8, 0);
        line( histImage, Point( bin_w*(i-1), hist_h - cvRound(g_hist.at<float>(i-1)) ),
              Point( bin_w*(i), hist_h - cvRound(g_hist.at<float>(i)) ),
              Scalar( 0, 255, 0), 2, 8, 0  );
        line( histImage, Point( bin_w*(i-1), hist_h - cvRound(r_hist.at<float>(i-1)) ),
              Point( bin_w*(i), hist_h - cvRound(r_hist.at<float>(i)) ),
              Scalar( 0, 0, 255), 2, 8, 0  );
    }

    imwrite(filename, histImage);
}

int main(int argc, char** argv) 
{
    VideoCapture cap(0); // Abre a webcam padrão
    if (!cap.isOpened()) {
        cout << "Erro ao abrir a webcam!" << endl;
        return -1;
    }

    Mat frame, b_equalized, g_equalized, r_equalized;
    Mat channels_equalized;

    while (true) 
    {
        cap >> frame; // Captura um frame da webcam
        if (frame.empty()) 
        {
            cout << "Erro ao capturar frame!" << endl;
            break;
        }
        	
		vector<Mat> bgr_planes; // Cria um vetor do tipo Mat
		split( frame, bgr_planes ); // Divide a imagem em canais BGR no vetor declarado acima
		
		equalizeHist(bgr_planes[0], b_equalized); // equalizando os histogramas de cada canal individualmente
		equalizeHist(bgr_planes[1], g_equalized);
		equalizeHist(bgr_planes[2], r_equalized);
 
		bool uniform = true, accumulate = false;
 
		Mat b_Eq_hist, g_Eq_hist, r_Eq_hist; // b_Eq_hist = blue equalized histogram
		
		// Calculo dos histogramas equalizados dos 3 canais. 
		calcHist( &b_equalized, 1, 0, Mat(), b_Eq_hist, 1, &histSize, histRange, uniform, accumulate );
		calcHist( &g_equalized, 1, 0, Mat(), g_Eq_hist, 1, &histSize, histRange, uniform, accumulate );
		calcHist( &r_equalized, 1, 0, Mat(), r_Eq_hist, 1, &histSize, histRange, uniform, accumulate );

		Mat b_hist, g_hist, r_hist;
		
		// Calculo dos histogramas não equalizados dos 3 canais.
		calcHist( &bgr_planes[0], 1, 0, Mat(), b_hist, 1, &histSize, histRange, uniform, accumulate );
		calcHist( &bgr_planes[1], 1, 0, Mat(), g_hist, 1, &histSize, histRange, uniform, accumulate );
		calcHist( &bgr_planes[2], 1, 0, Mat(), r_hist, 1, &histSize, histRange, uniform, accumulate );

		vector<Mat> bgr_equalized_planes; 
		bgr_equalized_planes = {b_equalized, g_equalized, r_equalized}; //armazena os canais equalizados dentro do novo vetor
		merge(bgr_equalized_planes, channels_equalized); //une os 3 canais equalizados novamente para formar a imagem colorida
				
        imshow("Webcam - Equalized", channels_equalized);
		imshow("Webcam - Normal", frame);

        char c = (char)waitKey(30);
        if (c == 's') 
        {
            imwrite("webcam_equalized.jpg", channels_equalized);
            imwrite("webcam_not_equalized.jpg", frame);
            saveHistogramImage(b_Eq_hist, g_Eq_hist, r_Eq_hist, "webcam_with_histogram_equalization.jpg");
            saveHistogramImage(b_hist, g_hist, r_hist, "webcam_without_histogram_equalization.jpg");
        } 
        else if (c == 'q') 
        {
            break;
        }
    }

    cap.release();
    destroyAllWindows();

    return 0;
}
        </code></pre>
      	</div>
        
        <p class="normal-text">
        	Com o código acima, removeu-se a conversão para tons de cinza e separou-se a equalização das 3 cores. Abaixo, estão os resultados obtido com a webcam.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%204/webcam_not_equalized_pessoa.jpg">
              <h4 class="image-title">Imagem sem equalização (webcam)</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%204/webcam_equalized_pessoa.jpg">
              <h4 class="image-title">Imagem com equalização (webcam)</h4>
          </div>
        </section>
        
        <p class="normal-text">
        	Ademais, foram obtidos os histogramas.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%204/webcam_without_histogram_equalization_pessoa.jpg">
              <h4 class="image-title">Hisograma sem equalização (webcam)</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%204/webcam_with_histogram_equalization_pessoa.jpg">
              <h4 class="image-title">Hisograma com equalização (webcam)</h4>
          </div>
        </section>
        
        <p class="normal-text">
        	A partir do mesmo princípio, repetiu-se a análise com um objeto colorido.
        </p>

        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%204/webcam_not_equalized_objeto.jpg">
              <h4 class="image-title">Objeto sem equalização (webcam)</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%204/webcam_equalized_objeto.jpg">
              <h4 class="image-title">Objeto com equalização (webcam)</h4>
          </div>
        </section>
        
        <p class="normal-text">
        	Por fim, foram obtidos os histogramas.
        </p>
        
        <section class="image-gallery">
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%204/webcam_without_histogram_equalization_objeto.jpg">
              <h4 class="image-title">Objeto sem equalização (webcam)</h4>
          </div>
          <div class="image-content">
              <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%204/Parte%204/webcam_with_histogram_equalization_objeto.jpg">
              <h4 class="image-title">Objeto com equalização (webcam)</h4>
          </div>
        </section>
        
        
        

        <br>

        <h2>Conclusões e Comentários Finais</h2>
        <p class="normal-text">
        	Neste laboratório, foram exploradas diversas técnicas de processamento de imagens utilizando a biblioteca OpenCV, com foco na equalização de histograma e limiarização. Os experimentos realizados demonstraram melhorias significativas na qualidade das imagens e na precisão das operações de binarização.
		</p>
        
        <p class="normal-text">
        	Primeiramente, a equalização de histograma foi aplicada tanto em imagens em tons de cinza quanto em imagens coloridas. No caso das imagens em tons de cinza, a equalização redistribuiu os níveis de intensidade de forma mais uniforme, resultando em um contraste aprimorado. O código desenvolvido para essa etapa leu a imagem, converteu-a para tons de cinza, calculou o histograma e aplicou a equalização, salvando tanto a imagem original quanto a equalizada, além dos gráficos dos histogramas. A implementação foi bem-sucedida, conforme evidenciado pelos resultados obtidos.
        </p>
        
        <p class="normal-text">
        	Em seguida, o código foi modificado para capturar imagens da webcam e aplicar a equalização de histograma em tempo real. Este experimento demonstrou a eficácia da equalização em diferentes condições de iluminação e cenários ao vivo. O programa desenvolvido capturou a imagem da webcam, converteu-a para tons de cinza, aplicou a equalização e exibiu as imagens em janelas ao vivo, permitindo uma visualização imediata dos efeitos da equalização.
        </p>
        
        <p class="normal-text">
          No estudo da binarização, a equalização de histograma foi incluída antes da aplicação da limiarização para obter imagens binárias. A comparação entre as imagens binárias com e sem equalização mostrou que a equalização prévia melhora significativamente a clareza e definição das imagens binárias. O código desenvolvido para esta etapa modificou o programa anterior para incluir a limiarização após a equalização, resultando em imagens binárias mais precisas.
        </p>
        
        <p class="normal-text">
        	Por fim, foi explorada a equalização nas cores, onde cada canal de cor foi equalizado separadamente antes de serem combinados novamente na imagem colorida de saída. Este experimento mostrou que a equalização dos canais de cor individualmente pode melhorar a vivacidade e distribuição das cores na imagem final. O código desenvolvido separou os canais de cor, aplicou a equalização em cada um e os recombinou, resultando em imagens coloridas com melhor qualidade visual.
        </p>
        
        <p class="normal-text">
        	Os resultados obtidos confirmam a eficácia das técnicas estudadas e implementadas, destacando a importância da equalização de histograma para melhorar a qualidade visual das imagens e a precisão da binarização. Este laboratório proporcionou uma compreensão prática e aprofundada das operações básicas de processamento de imagens, preparando para desafios mais complexos no campo da visão computacional.
        </p>
        
    	</div>
    </section>
    </main>

    <footer class="footer">
        <p>&copy; 2024 PROCESSAMENTO DE VÍDEO - UFABC</p>
    </footer>

    <script>
        function scrollToSection(sectionId) {
            document.getElementById(sectionId).scrollIntoView({ behavior: 'smooth' });
        }

        window.addEventListener('scroll', () => {
            const header = document.getElementById('header');
            if (window.scrollY > 50) {
                header.classList.add('shrink');
            } else {
                header.classList.remove('shrink');
            }
        });
    </script>
</body>
</html>
