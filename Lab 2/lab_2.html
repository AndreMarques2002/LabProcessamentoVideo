<!DOCTYPE html> 
<html>
<head>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-image: url('https://raw.githubusercontent.com/AndreMarques2002/processamentoVideoLabs/main/Background.png');
            background-size: cover;
            text-transform: uppercase;
            font-weight: bold;
            margin: 0;
            overflow-x: hidden;
        }
        .header {
            width: 100%; 
            position: sticky;
            top: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #3a9793; 
            padding: 20px;
            box-shadow: 0 2px 4px 0 rgba(0,0,0,0.2);
            z-index: 1;
        }
        .logo {
            width: 100px;
        }
      .footer {
            width: 100%; 
            background-color: #3a9793; 
            text-align: center; 
            color: white;
            padding: 10px;
            
            bottom: 0;
            left: 0;
            z-index: 1;
        }

        .audio-player {
            position: absolute; 
            top: 150px; 
            right: 20px; 
        }
        .title {
            text-align: center; 
            margin-top: 20px; 
            color: white;
        }
        .section {
            margin: 20px; 
            color: white;
        }
        .normal-text {
            text-transform: none;
            text-align: justify;
            font-weight: normal;
        }
        
        .media-container {
            display: flex;
            justify-content: space-around;
            align-items: flex-start;
            gap: 20px;
        }
        .media-content {
            text-align: center;
        }
        video {
            max-width: 100%;
            height: auto;
        }
        
        .image-container {
            display: flex;
            justify-content: space-around;
            align-items: flex-start;
            gap: 20px;
        }
        .image-content {
            display: flex;
            flex-direction: column;
            align-items: center; /* Centraliza o conteúdo dentro da div */
    	}
        .image-content img{
        	text-align: center;
        	max-width: 600px;
            
            height: auto;
        }
        imgem {
            max-width: 100%;
            height: auto;
        }
        
        .media-content img,
        .media-content iframe {
            max-width: 100%;
        }
        .menu {
            display: flex;
            gap: 25px;
        }
        .menu-item {
            text-decoration: none;
            color: white;
            font-size: 20px;
        }
        .menu-item:hover {
            color: #006400;
        }
        .dropdown {
            position:relative; 
            display:inline-block; 
        }
        .dropdown-content {
            display:none; 
            position:absolute; 
            min-width: 160px; 
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); 
            z-index: 1; 
            background-color: #3a9793;
            text-align: center; 
        }
        .dropdown-content a {
            color:white;
            padding: 12px 16px; 
            text-decoration: none; 
            display: block; 
            white-space: nowrap;
        }
        .dropdown-content a:hover {
            color: #006400; /* Cor verde escuro quando o cursor passa por cima */
        }
        .dropdown:hover .dropdown-content {
            display: block; 
        }
        .logo {
            width: 100px;
        }
        .code-container {
            background-color: #3b4252;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .code-container pre {
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
        }
        .code-container code {
            color: #88c0d0;
        }
    </style>
    <title>Laboratório 2</title>
    <link rel="icon" href="https://raw.githubusercontent.com/AndreMarques2002/processamentoVideoLabs/main/ufabc_icon.png">
</head>
<body>
    <div class="header">
        <img src="https://raw.githubusercontent.com/AndreMarques2002/processamentoVideoLabs/main/ufabc_icon.png" alt="Logo UFABC" class="logo">
        
        <div class="menu">
            <a href="../index.html" class="menu-item">Home</a>
           
            <div class="dropdown">
                <a class="menu-item">Trabalhos</a>
                <div class="dropdown-content">
                    <a href="../Trabalho 1/trabalho_1.html">Trabalho T1</a>
                    <a href="../Trabalho 2/trabalho_2.html">Trabalho T2</a>
                    <a href="../Trabalho 3/trabalho_3.html">Trabalho T3</a>
                    <a href="../Trabalho 4/trabalho_4.html">Trabalho T4</a>
                    <a href="../Trabalho 5/trabalho_5.html">Trabalho T5</a>
                </div>
            </div>
           
            <div class="dropdown">
                <a class="menu-item">Relatórios</a>
                <div class="dropdown-content">
                    <a href="../Lab 1/lab_1.html">Laboratório 1</a>
                    <a href="lab_2.html">Laboratório 2</a>
                    <a href="../Lab 3/lab_3.html">Laboratório 3</a>
                    <a href="../Lab 4/lab_4.html">Laboratório 4</a>
                    <a href="../Lab 5/lab_5.html">Laboratório 5</a>
                </div>
            </div>
        </div>
    </div>

    <h1 class="title">Laboratório 2 - Filtragem</h1>

    <div class="section">
        <h2>Introdução</h2>
        <p class="normal-text">
            A filtragem de imagens é uma ferramenta essencial no processamento digital, com vasta aplicação em tarefas como redução de ruídos, detecção de bordas e aprimoramento visual. Esse processo consiste em aplicar filtros específicos sobre uma imagem 
            original, gerando uma nova versão com propriedades alteradas de acordo com o tipo de filtro escolhido.
        </p>
        
        <p class="normal-text">
            Dentre os principais filtros usados, destacam-se os de média, gaussiano, mediana e bilateral. Cada um deles influencia a imagem de maneira única, apresentando particularidades tanto na remoção de ruídos quanto na preservação de detalhes importantes. 
            O filtro de média realiza a suavização calculando a média dos pixels vizinhos, enquanto o gaussiano pondera os pixels mais próximos, atribuindo maior relevância a eles. Já o filtro mediano substitui o valor de cada pixel pela mediana de seus vizinhos, 
            e o filtro bilateral se diferencia por suavizar a imagem ao mesmo tempo em que mantém as bordas definidas, utilizando um método não linear.
        </p>

        <p class="normal-text">
            Neste sentido, o presente laboratório tem como objetivo investigar e comparar o impacto desses filtros em imagens digitais, aplicando diferentes tamanhos de kernel (3x3, 5x5, 7x7 e 11x11) para avaliar como a variação do kernel influencia os resultados. 
            Além disso, será avaliado o desempenho dos filtros em imagens corrompidas por ruído do tipo sal-e-pimenta. Por fim, será desenvolvido um programa capaz de realizar filtragem em tempo real utilizando a captura de vídeo de uma webcam, proporcionando uma 
            visão prática e dinâmica dessas técnicas.
        </p>
        
        <br>

        <h2>Fundamentos básicos</h2>
        <p class="normal-text">
            O processamento de imagens digitais envolve a manipulação de dados representados em uma matriz de pixels, com o objetivo de melhorar ou extrair informações relevantes. Uma das técnicas mais essenciais para essa manipulação é a filtragem de imagens, 
            que consiste na aplicação de operadores matemáticos para modificar as características visuais de uma imagem. Esses filtros são comumente utilizados para reduzir ruídos, destacar bordas e melhorar a qualidade da imagem.
        </p>

        <h3>Tipos de Filtros</h3>
        <h4>Filtro de Média (Mean Filtering)</h4>
        <p class="normal-text">
            O filtro de média é um exemplo de filtro linear, no qual o valor de cada pixel é substituído pela média dos valores dos seus vizinhos dentro de uma janela definida (kernel). Esse processo resulta em uma suavização da imagem, atenuando variações rápidas 
            de intensidade, como ruídos. No entanto, ele pode causar perda de detalhes importantes, como bordas.
        </p>

        <h4>Filtro Gaussiano</h4>
        <p class="normal-text">
            Esse filtro é baseado na convolução da imagem com uma função Gaussiana. Ele realiza uma suavização semelhante ao filtro de média, mas atribui pesos maiores para os pixels mais próximos do centro da janela, resultando em uma suavização mais suave e menos 
            propensa à distorção. O filtro Gaussiano é amplamente utilizado por sua capacidade de reduzir ruído mantendo a integridade das bordas​.
        </p>

        <h4>Filtro Mediana (Median Filtering)</h4>
        <p class="normal-text">
            O filtro de mediana é um método não linear, que substitui cada pixel pelo valor mediano dos pixels vizinhos em uma janela ao redor dele. Esse filtro é eficaz na remoção de ruídos do tipo sal-e-pimenta, preservando as bordas melhor do que os filtros lineares, 
            como o de média.
        </p>

        <h4>Filtro Bilateral</h4>
        <p class="normal-text">
            O filtro bilateral é um método não linear que suaviza a imagem ao mesmo tempo em que preserva as bordas. Ele combina filtragem espacial com filtragem baseada na intensidade, garantindo que apenas pixels com intensidades semelhantes sejam usados na 
            suavização, o que impede o desfoque das bordas​.
        </p>
        
        <h3>Convolução e Kernels</h3>
        <p class="normal-text">
            A operação de convolução é uma ferramenta central no processamento de imagens, na qual um kernel (ou máscara) é aplicado a cada pixel da imagem, produzindo uma nova imagem. A convolução pode ser usada tanto para suavização quanto para detecção de bordas. 
            Kernels maiores resultam em uma suavização mais acentuada, enquanto kernels menores preservam mais detalhes​
        </p>
        
        <br>

        <h2>Materiais e Métodos</h2>
        <h3>Lista de Materiais</h3>
            <ul>
                <li><p class="normal-text">Computador com o sistema opercional Linux 22.04 instalado</p></li>
                <li><p class="normal-text">Biblioteca OpenCV devidamente instalada</p></li>
                <li><p class="normal-text">Webcam Microsoft</p></li>
                <li><p class="normal-text">Imagens e vídeos de teste</p></li>
            </ul>
        
        <br>
        
        <h2>Procedimentos Experimentais</h2>
        <h3>Parte 1</h3>
        <p class="normal-text">
            Para o primeiro item da atividade, Foi necessário realizar algumas modificações no código base disponivel (<a href="https://docs.opencv.org/4.x/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html" target="_blank" style="color: white;">https://docs.opencv.org/4.x/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html</a>). Assim, a dinâmica do código original com as telas de legenda indicando o filtro seguinte e os laços que fazem com que o Kernel aumente gradativamente foram mantidas.
		</p>
        
        <p class="normal-text">
        	Assim, alterou-se o método utilizado para obter a imagem que sofrerá os filtros para que o programa buscasse em nossa pasta diretamente ao invés de usar as imagens próprias do OpenCV da pasta samples:

		<div class="code-container">
		<pre><code>

int main( int argc, char ** argv )
{
 namedWindow( window_name, WINDOW_AUTOSIZE );
 const char* filename = "grupo.jpg";
 src = imread(filename, IMREAD_COLOR );
 		</code></pre>
		</div>

		<p class="normal-text">
        Ademais, modificou-se também o valor máximo do Kernel de acordo com o que foi solicitado no relatório (3,5,7 e 11) ajustando diretamente na declaração da variável MAX_KERNEL_LENGTH. Nesse caso, refere-se ao código feito para Kernel 5x5:
		</p>
        
        <div class="code-container">
		<pre><code>

int DELAY_CPATION = 1500;
int DELAY_BLUR = 1000;
int MAX_KERNEL_LENGTH = 5;
			</code></pre>
            </div>


		<p class="normal-text">
        No programa original, o Kernel é aumentado gradativamente até atingir seu valor máximo e consequentemente causar um efeito de filtro mais intenso na imagem. Para que essa imagem com o filtro máximo aplicado fosse salva, adicionou-se o comando <em>imwrite</em> após o encerramento do laço for:
		</p>
        
        <div class="code-container">
		<pre><code>

if( display_caption( "Filtro de media" ) != 0 )
{
 return 0;
 }
 
 for( int i = 1; i < MAX_KERNEL_LENGTH; i = i + 1 )
 {
  blur( src, dst, Size( i, i ), Point(-1,-1) );
  if( display_dst( DELAY_BLUR ) != 0 )
  {
  return 0;
 }
}
imwrite("Grupo_FiltroDeMediaK5", dst);

			</code></pre>
            </div>

		<p class="normal-text">
        	Repetiu-se esse comando para os 4 tipos de filtro resultando em um salvamento automático das imagens já com os filtros aplicados. Variando os valores da variável MAX_KERNEL_LENGTH, foi possível obter as imagens com Kernel 3x3, 5x5, 7x7 e 11x11
        </p>

        <h3>Parte 2</h3>
        <p class="normal-text">
        	Nesta parte, repetiu-se os passos do item anterior. Todavia, acrescentou-se o ruído Sal e Pimenta como mostra o bloco abaixo:
        </p>
		<div class="code-container">
		<pre><code>
int main( int argc, char ** argv )
{
 namedWindow( window_name, WINDOW_AUTOSIZE );
 
 const char* filename = "GrupoRuido.jpg";
 
 src = imread(filename, IMREAD_COLOR );
 if (src.empty())
 {
 printf(" Erro ao abrir as imagens\n");
 printf(" Usage:\n %s [image_name-- default grupo.jpg] \n", argv[0]);
 return EXIT_FAILURE;
 }
 		</code></pre>
        </div>
        
        <h3>Parte 3</h3>
        <p class="normal-text">
        	Na terceita parte, confeccionou-se um código a fim de que o filtro Gaussiano fosse implementado na webcam.
		</p>
        
        <h3>Parte 4</h3>
        <p class="normal-text">
        Foi elaborado um programa de filtragem para entrada de webcam, exibindo o resultado da filtragem em uma janela do OpenCV. O programa permite ao usuário escolher o tipo de filtragem e o tamanho do kernel. 
        </p>
        <p class="normal-text">
        A seleção dos filtros é feita através das teclas [a], [g], [m], e [b], correspondentes aos filtros de média, gaussiano, mediana e bilateral, respectivamente. O tamanho do kernel é ajustado utilizando as teclas [3], [5], [7], [9] e [B], que representam os tamanhos de kernel 3x3, 5x5, 7x7, 9x9 e 11x11, respectivamente
        </p>
        

        <br>
        
        <h2>Resultados e Análises</h2>
        <p class="normal-text">
            Com os códigos desenvolvidos e alterados, foi possível obter os resultados abaixo.
        </p>
        
        <h3>Parte 1</h3>
        
        <h4>Kernel 3x3</h4>
        <div class="image-container">
        <div class="image-content">
            <p>Filtro de Média</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel3/Grupo_FiltroDeMediaK3.jpg">
        </div>
        <div class="image-content">
            <p>Filtro de Mediana</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel3/Grupo_FiltroDeMedianaK3.jpg">
        </div>
    	</div>
        
        <div class="image-container">
        <div class="image-content">
            <p>Filtro Gaussiano</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel3/Grupo_FiltroGaussianoK3.jpg">
        </div>
        <div class="image-content">
            <p>Filtro Bilateral</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel3/Grupo_FiltroBilateralK3.jpg">
        </div>
    	</div>
        
        <p class="normal-text">
        	Nota-se que para o kernel 3x3 as mudanças parecem ser mínimas e quase não aparentes.
		</p>
        
        <h4>Kernel 5x5</h4>
        <div class="image-container">
        <div class="image-content">
            <p>Filtro de Média</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel5/Grupo_FiltroDeMediaK5.jpg">
        </div>
        <div class="image-content">
            <p>Filtro de Mediana</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel5/Grupo_FiltroDeMedianaK5.jpg">
        </div>
    	</div>
        
        <div class="image-container">
        <div class="image-content">
            <p>Filtro Gaussiano</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel5/Grupo_FiltroGaussianoK5.jpg">
        </div>
        <div class="image-content">
            <p>Filtro Bilateral</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel5/Grupo_FiltroBilateralK5.jpg">
        </div>
    	</div>
        
        <p class="normal-text">
        	Utilizando kernel 5x5 é possível notar os filtros aplicados, especialmente o de média e o de mediana.
		</p>
        
        
        <h4>Kernel 7x7</h4>
        <div class="image-container">
        <div class="image-content">
            <p>Filtro de Média</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel7/Grupo_FiltroDeMediaK7.jpg">
        </div>
        <div class="image-content">
            <p>Filtro de Mediana</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel7/Grupo_FiltroDeMedianaK7.jpg">
        </div>
    	</div>
        
        <div class="image-container">
        <div class="image-content">
            <p>Filtro Gaussiano</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel7/Grupo_FiltroGaussianoK7.jpg">
        </div>
        <div class="image-content">
            <p>Filtro Bilateral</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel7/Grupo_FiltroBilateralK7.jpg">
        </div>
    	</div>
        
        <p class="normal-text">
        	A aplicação do filtro com kernel 7x7 apresentou uma suavização eficaz, equilibrando a remoção de ruídos e a preservação de detalhes, embora tenha causado uma leve perda de nitidez nas bordas.
		</p>
        
        
        <h4>Kernel 11x11</h4>
        <div class="image-container">
        <div class="image-content">
            <p>Filtro de Média</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel11/Grupo_FiltroDeMediaK11.jpg">
        </div>
        <div class="image-content">
            <p>Filtro de Mediana</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel11/Grupo_FiltroDeMedianaK11.jpg">
        </div>
    	</div>
        
        <div class="image-container">
        <div class="image-content">
            <p>Filtro Gaussiano</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel11/Grupo_FiltroGaussianoK11.jpg">
        </div>
        <div class="image-content">
            <p>Filtro Bilateral</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%201/Kernel11/Grupo_FiltroBilateralK11.jpg">
        </div>
    	</div>
        
        <p class="normal-text">
        	Com o kernel 11x11, a suavização aumentou consideravelmente, resultando em uma imagem mais desfocada, o que pode ser indesejável para aplicações que exigem detalhes mais nítidos.
		</p>
        
        <h3>Parte 2</h3>
        <p class="normal-text">
        	Para esse item, utilizou-se o código disponibilizado no arquivo “Sal e Pimenta” e modificou-se a parte responsável pelo carregamento da foto do grupo. O resultado foi o seguinte:
		</p>
        <div class="image-container">
        <div class="image-content">
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/GrupoRuido.jpg">
        </div>
        </div>
        
        <p class="normal-text">
        	Não foram necessárias outras alterações no código original para além do nome da imagem e mantivemos os valores de ruído padrão pa = 0,05 e pb = 0,05.
        </p>
        
        <h4>Kernel 3x3</h4>
        <div class="image-container">
        <div class="image-content">
            <p>Filtro de Média</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel3/Grupo_FiltroDeMediaK3.jpg">
        </div>
        <div class="image-content">
            <p>Filtro de Mediana</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel3/Grupo_FiltroDeMedianaK3.jpg">
        </div>
    	</div>
        
        <div class="image-container">
        <div class="image-content">
            <p>Filtro Gaussiano</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel3/Grupo_FiltroGaussianoK3.jpg">
        </div>
        <div class="image-content">
            <p>Filtro Bilateral</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel3/Grupo_FiltroBilateralK3.jpg">
        </div>
    	</div>
        
        <p class="normal-text">
        	Aplicando os filtros na imagem com ruído, observamos que tanto no filtro de média quanto no filtro Gaussiano ocorre uma diminuição dos ruídos brancos. O filtro bilateral não parece ter muito efeito em relação a melhorar a visibilidade da imagem, enquanto que o filtro de mediana surpreendentemente, mesmo com kernel 3x3 possibilita a visualização da imagem 
praticamente sem o ruído inicial.
		</p>

        
        <h4>Kernel 5x5</h4>
        <div class="image-container">
        <div class="image-content">
            <p>Filtro de Média</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel5/Grupo_FiltroDeMediaK5.jpg">
        </div>
        <div class="image-content">
            <p>Filtro de Mediana</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel5/Grupo_FiltroDeMedianaK5.jpg">
        </div>
    	</div>
        
        <div class="image-container">
        <div class="image-content">
            <p>Filtro Gaussiano</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel5/Grupo_FiltroGaussianoK5.jpg">
        </div>
        <div class="image-content">
            <p>Filtro Bilateral</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel5/Grupo_FiltroBilateralK5.jpg">
        </div>
    	</div>
        
        <p class="normal-text">
        	O uso do kernel 5x5 foi eficiente na remoção de ruído sal-e-pimenta, proporcionando uma boa suavização enquanto preservava a maioria dos detalhes importantes da imagem.
		</p>
        
        
        <h4>Kernel 7x7</h4>
        <div class="image-container">
        <div class="image-content">
            <p>Filtro de Média</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel7/Grupo_FiltroDeMediaK7.jpg">
        </div>
        <div class="image-content">
            <p>Filtro de Mediana</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel7/Grupo_FiltroDeMedianaK7.jpg">
        </div>
    	</div>
        
        <div class="image-container">
        <div class="image-content">
            <p>Filtro Gaussiano</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel7/Grupo_FiltroGaussianoK7.jpg">
        </div>
        <div class="image-content">
            <p>Filtro Bilateral</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel7/Grupo_FiltroBilateralK7.jpg">
        </div>
    	</div>
        
        <p class="normal-text">
        	Com o kernel 7x7, a filtragem melhorou ainda mais a remoção do ruído, mas começou a introduzir uma suavização excessiva, o que resultou em uma leve perda de nitidez nas bordas.
        </p>
        
        
        <h4>Kernel 11x11</h4>
        <div class="image-container">
        <div class="image-content">
            <p>Filtro de Média</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel11/Grupo_FiltroDeMediaK11.jpg">
        </div>
        <div class="image-content">
            <p>Filtro de Mediana</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel11/Grupo_FiltroDeMedianaK11.jpg">
        </div>
    	</div>
        
        <div class="image-container">
        <div class="image-content">
            <p>Filtro Gaussiano</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel11/Grupo_FiltroGaussianoK11.jpg">
        </div>
        <div class="image-content">
            <p>Filtro Bilateral</p>
            <img src="https://raw.githubusercontent.com/AndreMarques2002/LabProcessamentoVideo/main/Lab%202/Parte%202/Kernel11/Grupo_FiltroBilateralK11.jpg">
        </div>
    	</div>
        
        <p class="normal-text">
        	O kernel 11x11 mostrou-se eficaz na suavização do ruído, porém comprometeu significativamente a definição da imagem, tornando-a mais desfocada e menos adequada para visualização de detalhes.
        </p>
        
        
        <h3>Parte 3</h3>
        <p class="normal-text">
        	Na Parte 3 da atividade, utilizou-se o código de reprodução de vídeo da webcam trabalhado no Laboratório 1 (<a href="https://learnopencv.com/reading-and-writing-videos-using-opencv/" target="_blank" style="color: white;">https://learnopencv.com/reading-and-writing-videos-using-opencv/</a>) “Read Video from a Webcam”.
        <p class="normal-text">
        	Neste sentido, optou-se por utilizar o filtro Gaussiano, dessa forma, adicionar a função de aplicação do filtro antes da exibição em vídeo, sendo aplicada em cada frame gerado. Por fim, adicionou-se uma condição de modo que ao apertar a tecla “s”, uma imagem referente ao momento em que a tecla foi acionada é salva com o nome “Cena.jpg”:
		</p>
        
        
        
        
        
        <div class="code-container">
		<pre><code>
// Include Libraries
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;

// Namespace to nullify use of cv::function(); syntax
using namespace std;
using namespace cv;

int main()
{
	// initialize a video capture object
	VideoCapture vid_capture(0);

	// Print error message if the stream is invalid
	if (!vid_capture.isOpened())
	{
		cout << "Error opening video stream or file" << endl;
	}
	
	// Read the frames to the last frame
	while (vid_capture.isOpened())
	{
		// Initialise frame matrix
		Mat frame; Mat dst;

	    // Initialize a boolean to check if frames are there or not
		bool isSuccess = vid_capture.read(frame);

		// If frames are present, show it
		if(isSuccess == true)
		{
			//display frames
			GaussianBlur( frame, dst, Size( 109, 109 ), 0, 0 );
			imshow("Frame", dst);
			int k = waitKey(1); // Wait for a keystroke in the window
			if(k == 's')
			{
				imwrite("cena.jpg", dst);
			}
		}

		// If frames are not there, close it
		if (isSuccess == false)
		{
			cout << "Video camera is disconnected" << endl;
			break;
		}
		
		//wait 20 ms between successive frames and break the loop if key q is pressed
		int k = waitKey(20);
		if (k == 113)
		{
			cout << "Q key is pressed by the user. Stopping the video" << endl;
			break;
		}
		
	}
	destroyAllWindows();
	vid_capture.release();
	return 0;
}

			</code></pre>
            </div>
        
        <h3>Parte 4</h3>
        <p class="normal-text">
            A partir do filtro Gaussiano, elaborou-se o código abaixo utilizando a webcam como entrada.
        </p>
        <div class="code-container">
            <pre><code>
			<pre><code>
// Include Libraries
#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;map&gt;
			</code></pre>


using namespace std;
using namespace cv;

void applyFilter(const Mat& frame, Mat& filtered_frame, int filterType, int kernelSize) {
	switch (filterType) {
		case 0: blur(frame, filtered_frame, Size(kernelSize, kernelSize)); break;
		case 1: GaussianBlur(frame, filtered_frame, Size(kernelSize, kernelSize), 0); break;
		case 2: medianBlur(frame, filtered_frame, kernelSize); break;
		case 3: bilateralFilter(frame, filtered_frame, kernelSize, kernelSize * 2, kernelSize / 2); break;
		default: filtered_frame = frame; break;
	}
}

int main() {
	VideoCapture cap(0);
	if (!cap.isOpened()) {
		cerr << "Erro ao abrir a webcam!" << endl;
		return -1;
	}
    
	Mat frame, filtered_frame;
	char key;
	int kernelSize = 3;
	int filterType = 0;

	map<char, int> filterMap = {{'a', 0}, {'g', 1}, {'m', 2}, {'b', 3}};
	map<char, int> kernelMap = {{'3', 3}, {'5', 5}, {'7', 7}, {'9', 9}, {'B', 11}};

	while (true) {
    	cap >> frame;
        if (frame.empty()) {
			cerr << "Erro ao capturar imagem da webcam!" << endl;
            break;
		}

        applyFilter(frame, filtered_frame, filterType, kernelSize);
        imshow("Filtragem da Webcam", filtered_frame);

        key = waitKey(30);
        if (filterMap.find(key) != filterMap.end()) {
            filterType = filterMap[key];
        } else if (kernelMap.find(key) != kernelMap.end()) {
        kernelSize = kernelMap[key];
        } else if (key == 'q') {
        break;
    	}
	}

	cap.release();
	destroyAllWindows();
	return 0;
}
            </code></pre>
        </div>

        
        <br>
      
        <h2>Conclusões e Comentários Finais</h2>
        <p class="normal-text">
        	Os experimentos com diferentes tipos de filtros (média, gaussiano, mediana e bilateral) e tamanhos de kernel mostraram que a escolha do método de filtragem depende da natureza da imagem e do objetivo desejado.
		</p>
		<p class="normal-text">
            O filtro de mediana foi o mais eficaz na remoção de ruído sSal e Pimenta, preservando os detalhes da imagem, enquanto o filtro bilateral destacou-se por suavizar sem perder as bordas. O filtro de média e o gaussiano, embora eficientes para suavização geral, causaram perda significativa de detalhes, especialmente com kernels maiores. Em aplicações com ruído intenso, o filtro de mediana foi o mais indicado.
        </p>
        
    </div>

    <div class="footer">
        <p>PROCESSAMENTO DE VÍDEO</p>
    </div>
</body>
</html>
